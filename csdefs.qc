/*
Extensions file for QSS 2021-05-11
This file is auto-generated by pr_dumpplatform -O csdefs -Tcs.
You will probably need to use FTEQCC to compile this.
*/


//This file only supports csqc, so including this file in some other situation is a user error
#if defined(QUAKEWORLD) || defined(MENU)
#error Mixed up module defs
#endif
#if !defined(CSQC) && !defined(SSQC) && !defined(MENU)
#define CSQC
#ifndef CSQC_SIMPLE
#define CSQC_SIMPLE
#endif
#endif

void() main = {};
void() StartFrame = {};
void() PlayerPreThink = {};
void() PlayerPostThink = {};
void() ClientKill = {};
void() ClientConnect = {};
void() PutClientInServer = {};
void() ClientDisconnect = {};
void() SetNewParms = {};
void() SetChangeParms = {};

//Some custom types (that might be redefined as accessors by fteextensions.qc, although we don't define any methods here)
#ifdef _ACCESSORS
accessor strbuf:float;
accessor searchhandle:float;
accessor hashtable:float;
accessor infostring:string;
accessor filestream:float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

//Common entry points
void(string cmdtext) GameCommand = {};
void() EndFrame = {};

//CSQC entry points
void(vector virtsize, float showscores) CSQC_DrawHud;
void(float apilevel, string enginename, float engineversion) CSQC_Init;
void(vector virtsize, float showscores) CSQC_DrawScores;
/*
float(float save, float take, vector dir) CSQC_Parse_Damage = {return 0;};
void(float vwidth, float vheight, float notmenu) CSQC_UpdateView;
void() CSQC_Shutdown = {};
float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent = {return 0;};
float(string cmdstr) CSQC_ConsoleCommand = {return 0;};
void() CSQC_Parse_Event = {};
void() CSQC_Input_Frame = {};
float(string msg) CSQC_Parse_CenterPrint = {return 0;};
void(string printmsg, float printlvl) CSQC_Parse_Print = {};
void(float isnew) CSQC_Ent_Update = {};
void() CSQC_Ent_Remove = {};
float() CSQC_Parse_TempEntity = {return 0;};
void(string msg) CSQC_Parse_StuffCmd = {};*/

//================================================

#pragma noref 1

float input_timelength;
vector input_movevalues;
vector input_angles;
float input_buttons;
float input_impulse;
int input_weapon;
vector input_cursor_screen;
vector input_cursor_trace_start;
vector input_cursor_trace_endpos;
float input_cursor_entitynumber;

float physics_mode;
float cltime;
float clframetime;

float maxclients;

float intermission;
float intermission_time;

float player_localnum;
float player_localentnum;

vector view_angles;

float clientcommandframe;
float servercommandframe;

const float MASK_ENGINE = 1;
const float MASK_VIEWMODEL = 2;

const float GE_MAXENTS = -1;
const float GE_ACTIVE = 0;
const float GE_ORIGIN = 1;
const float GE_FORWARD = 2;
const float GE_RIGHT = 3;
const float GE_UP = 4;
const float GE_SCALE = 5;
const float GE_ORIGINANDVECTORS = 6;
const float GE_ALPHA = 7;
const float GE_COLORMOD = 8;
const float GE_PANTSCOLOR = 9;
const float GE_SHIRTCOLOR = 10;
const float GE_SKIN = 11;

__used var float physics_mode = 2;

const float MF_ROCKET			= 0x1;
const float MF_GRENADE			= 0x2;
const float MF_GIB				= 0x4;
const float MF_ROTATE			= 0x8;
const float MF_TRACER			= 0x10;
const float MF_ZOMGIB			= 0x20;
const float MF_TRACER2			= 0x40;
const float MF_TRACER3			= 0x80;

const float EF_FULLBRIGHT = 512;
const float EF_NOSHADOW = 4096;
const float EF_NOMODELFLAGS = 8388608;

const float IE_KEYDOWN		= 0;
const float IE_KEYUP		= 1;
const float IE_MOUSEDELTA	= 2;
const float IE_MOUSEABS		= 3;
const float IE_JOYAXIS		= 6;

const float VF_MIN = 1;
const float VF_MIN_X = 2;
const float VF_MIN_Y = 3;
const float VF_SIZE = 4;
const float VF_SIZE_X = 5;
const float VF_SIZE_Y = 6;
const float VF_VIEWPORT = 7;
const float VF_FOV = 8;
const float VF_FOV_X = 9;
const float VF_FOV_Y = 10;
const float VF_ORIGIN = 11;
const float VF_ORIGIN_X = 12;
const float VF_ORIGIN_Y = 13;
const float VF_ORIGIN_Z = 14;
const float VF_ANGLES = 15;
const float VF_ANGLES_X = 16;
const float VF_ANGLES_Y = 17;
const float VF_ANGLES_Z = 18;
const float VF_DRAWWORLD = 19;
const float VF_DRAWENGINESBAR = 20;
const float VF_DRAWCROSSHAIR = 21;

const float VF_CL_VIEWANGLES = 33;
const float VF_CL_VIEWANGLES_X = 34;
const float VF_CL_VIEWANGLES_Y = 35;
const float VF_CL_VIEWANGLES_Z = 36;
const float VF_ACTIVESEAT = 202;

const float VF_AFOV = 203;
const float VF_SCREENVSIZE = 204;
const float VF_SCREENPSIZE = 205;

const float RF_VIEWMODEL = 1;
const float RF_EXTERNALMODEL = 2;
const float RF_DEPTHHACK = 4;
const float RF_ADDITIVE = 8;
const float RF_USEAXIS = 16;
const float RF_NOSHADOW = 32;
const float RF_WEIRDFRAMETIMES = 64;

const float PRECACHE_PIC_FROMWAD = 1;
const float PRECACHE_PIC_WRAP = 4;
const float PRECACHE_PIC_MIPMAP = 8;
const float PRECACHE_PIC_TEST = 512;

const float SLIST_HOSTCACHEVIEWCOUNT = 0;
const float SLIST_HOSTCACHETOTALCOUNT = 1;
const float SLIST_SORTFIELD = 6;
const float SLIST_SORTDESCENDING = 7;

const float GGDI_GAMEDIR = 0;
const float GGDI_LOADCOMMAND = 3;

const float EV_VOID = 0;
const float EV_STRING = 1;
const float EV_FLOAT = 2;
const float EV_VECTOR = 3;
const float EV_ENTITY = 4;
const float EV_FIELD = 5;
const float EV_FUNCTION = 6;
const float EV_POINTER = 7;
const float EV_INTEGER = 8;

//Supported Extension fields
const float FILE_READ		= 0;
const float FILE_APPEND		= 1;
const float FILE_WRITE		= 2;

//Builtin list

vector(vector fwd, optional vector up) vectoangles2 = #51; /*
		Returns the angles (+x=UP) required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

float(float angle) sin = #60;
float(float angle) cos = #61;
float(float value) sqrt = #62;
void(entity ent, entity ignore) tracetoss = #64;
string(entity ent) etos = #65;
float(entity ent) etof = #0;
entity(float ent) ftoe = #0;
float(string) stof = #81;
void(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) tracebox = #90; /*
		Exactly like traceline, but a box instead of a uselessly thin point. Acceptable sizes are limited by bsp format, q1bsp has strict acceptable size values. */

vector() randomvec = #91; /*
		Returns a vector with random values. Each axis is independantly a value between -1 and 1 inclusive. */

vector(vector org) getlight = #92;
float(string cvarname, string defaultvalue) registercvar = #93; /*
		Creates a new cvar on the fly. If it does not already exist, it will be given the specified value. If it does exist, this is a no-op.
		This builtin has the limitation that it does not apply to configs or commandlines. Such configs will need to use the set or seta command causing this builtin to be a noop.
		In engines that support it, you will generally find the autocvar feature easier and more efficient to use. */

float(float a, float b, ...) min = #94; /*
		Returns the lowest value of its arguments. */

float(float a, float b, ...) max = #95; /*
		Returns the highest value of its arguments. */

float(float minimum, float val, float maximum) bound = #96; /*
		Returns val, unless minimum is higher, or maximum is less. */

float(float value, float exp) pow = #97;
#define findentity findfloat
entity(entity start, .__variant fld, __variant match) findfloat = #98; /*
		Equivelent to the find builtin, but instead of comparing strings contents, this builtin compares the raw values. This builtin requires multiple calls in order to scan all entities - set start to the previous call's return value.
		world is returned when there are no more entities. */

float(string extname) checkextension = #99; /*
		Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
		Use cvar("pr_checkextension") to see if this builtin exists. */

float(__variant funcref) checkbuiltin = #0; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. */

float(string builtinname) builtin_find = #100; /*
		Looks to see if the named builtin is valid, and returns the builtin number it exists at. */

float(float value) anglemod = #102;
filestream(string filename, float mode, optional float mmapminsize) fopen = #110; /*
		Opens a file, typically prefixed with "data/", for either read or write access. */

void(filestream fhandle) fclose = #111;
string(filestream fhandle) fgets = #112; /*
		Reads a single line out of the file. The new line character is not returned as part of the string. Returns the null string on EOF (use if not(string) to easily test for this, which distinguishes it from the empty string which is returned if the line being read is blank */

void(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) fputs = #113; /*
		Writes the given string(s) into the file. For compatibility with fgets, you should ensure that the string is terminated with a \n - this will not otherwise be done for you. It is up to the engine whether dos or unix line endings are actually written. */

#define ftell fseek //c-compat
int(filestream fhandle, optional int newoffset) fseek = #0; /*
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

float(string s) strlen = #114;
string(string s1, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) strcat = #115;
string(string s, float start, float length) substring = #116;
vector(string s) stov = #117;
string(string s, ...) strzone = #118; /*
		Create a semi-permanent copy of a string that only becomes invalid once strunzone is called on the string (instead of when the engine assumes your string has left scope). */

void(string s) strunzone = #119; /*
		Destroys a string that was allocated by strunzone. Further references to the string MAY crash the game. */

float(string s) tokenize_menuqc = #0;
void(string soundname, optional float channel, optional float volume) localsound = #177; /*
		Plays a sound... locally... probably best not to call this from ssqc. Also disables reverb. */

float(float number, float quantity) bitshift = #218;
float(string s1, string sub, optional float startidx) strstrofs = #221; /*
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /*
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /*
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /*
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /*
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /*
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /*
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /*
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /*
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /*
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0; /*
		Trims the whitespace from the start+end of the string. */

float(vector viewpos, entity entity) checkpvs = #240;
float(float a, float n) mod = #245;
int(string) stoi = #259; /*
		Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /*
		Converts the passed true integer into a base10 string. */

int(string) stoh = #261; /*
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /*
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

int(float) ftoi = #0; /*
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0; /*
		Converts the given true integer into a float without depending on extended qcvm instructions. */

#ifndef dotproduct
#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
#endif
vector(vector v1, vector v2) crossproduct = #0; /*
		Small helper function to calculate the crossproduct of two vectors. */

float(float modidx, string framename) frameforname = #276; /*
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /*
		Retrieves the duration (in seconds) of the specified framegroup. */

void(optional entity ent, optional vector neworigin) touchtriggers = #279; /*
		Triggers a touch events between self and every SOLID_TRIGGER entity that it is in contact with. This should typically just be the triggers touch functions. Also optionally updates the origin of the moved entity. */

string(float modidx, float framenum) frametoname = #284;
float(string name) checkcommand = #294; /*
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

void(float mask) addentities = #301; /*
		Walks through all entities effectively doing this:
		 if (ent.drawmask&mask){ if (!ent.predaw()) addentity(ent); }
		If mask&MASK_DELTA, non-csqc entities, particles, and related effects will also be added to the rentity list.
		 If mask&MASK_STDVIEWMODEL then the default view model will also be added. */

void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

float(vector org, float radius, vector lightcolours, optional float style, optional string cubemapname, optional float pflags) dynamiclight_add = #305; /*
		Adds a temporary dlight, ready to be drawn via addscene. Cubemap orientation will be read from v_forward/v_right/v_up. */

void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

vector (vector v) unproject = #310; /*
		Transform a 2d screen-space point (with depth) into a 3d world-space point, according the various origin+angle+fov etc settings set via setproperty. */

vector (vector v) project = #311; /*
		Transform a 3d world-space point into a 2d screen-space point, according the various origin+angle+fov etc settings set via setproperty. */

float(string name) iscachedpic = #316; /*
		Checks to see if the image is currently loaded. Engines might lie, or cache between maps. */

string(string name, optional float flags) precache_pic = #317; /*
		Forces the engine to load the named image. If trywad is specified, the specified name must any lack path and extension. */

#define draw_getimagesize drawgetimagesize
vector(string picname) drawgetimagesize = #318; /*
		Returns the dimensions of the named image. Images specified with .lmp should give the original .lmp's dimensions even if texture replacements use a different resolution. */

float(vector position, float character, vector size, vector rgb, float alpha, optional float drawflag) drawcharacter = #320; /*
		Draw the given quake character at the given position.
		If flag&4, the function will consider the char to be a unicode char instead (or display as a ? if outside the 32-127 range).
		size should normally be something like '8 8 0'.
		rgb should normally be '1 1 1'
		alpha normally 1.
		Software engines may assume the named defaults.
		Note that ALL text may be rescaled on the X axis due to variable width fonts. The X axis may even be ignored completely. */

float(vector position, string text, vector size, vector rgb, float alpha, optional float drawflag) drawrawstring = #321; /*
		Draws the specified string without using any markup at all, even in engines that support it.
		If UTF-8 is globally enabled in the engine, then that encoding is used (without additional markup), otherwise it is raw quake chars.
		Software engines may assume a size of '8 8 0', rgb='1 1 1', alpha=1, flag&3=0, but it is not an error to draw out of the screen. */

float(vector position, string pic, vector size, vector rgb, float alpha, optional float drawflag) drawpic = #322; /*
		Draws an shader within the given 2d screen box. Software engines may omit support for rgb+alpha, but must support rescaling, and must clip to the screen without crashing. */

float(vector position, vector size, vector rgb, float alpha, optional float drawflag) drawfill = #323; /*
		Draws a solid block over the given 2d box, with given colour, alpha, and blend mode (specified via flags).
		flags&3=0 simple blend.
		flags&3=1 additive blend */

void(float x, float y, float width, float height) drawsetcliparea = #324; /*
		Specifies a 2d clipping region (aka: scissor test). 2d draw calls will all be clipped to this 2d box, the area outside will not be modified by any 2d draw call (even 2d polygons). */

void(void) drawresetcliparea = #325; /*
		Reverts the scissor/clip area to the whole screen. */

float(vector position, string text, vector size, vector rgb, float alpha, float drawflag) drawstring = #326; /*
		Draws a string, interpreting markup and recolouring as appropriate. */

float(string text, float usecolours, vector fontsize='8 8') stringwidth = #327; /*
		Calculates the width of the screen in virtual pixels. If usecolours is 1, markup that does not affect the string width will be ignored. Will always be decoded as UTF-8 if UTF-8 is globally enabled.
		If the char size is not specified, '8 8 0' will be assumed. */

void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, optional float drawflag) drawsubpic = #328; /*
		Draws a rescaled subsection of an image to the screen. */

#define getstati_punf(stnum) (float)(__variant)getstati(stnum)
int(float stnum) getstati = #330; /*
		Retrieves the numerical value of the given EV_INTEGER or EV_ENTITY stat. Use getstati_punf if you wish to type-pun a float stat as an int to avoid truncation issues in DP. */

#define getstatbits getstatf
float(float stnum, optional float firstbit, optional float bitcount) getstatf = #331; /*
		Retrieves the numerical value of the given EV_FLOAT stat. If firstbit and bitcount are specified, retrieves the upper bits of the STAT_ITEMS stat (converted into a float, so there are no VM dependancies). */

string(float stnum) getstats = #332; /*
		Retrieves the value of the given EV_STRING stat, as a tempstring.
		String stats use a separate pool of stats from numeric ones. */

void(entity e, float mdlindex) setmodelindex = #333; /*
		Sets a model by precache index instead of by name. Otherwise identical to setmodel. */

float(string effectname) particleeffectnum = #335; /*
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /*
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /*
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument. */

void(string s, ...) cprint = #338; /*
		Print into the center of the screen just as ssqc's centerprint would appear. */

void(string s, ...) print = #339; /*
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

string(float keynum) keynumtostring = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

float(string keyname) stringtokeynum = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

string(float keynum) getkeybind = #342; /*
		Returns the current binding for the given key (returning only the command executed when no modifiers are pressed). */

void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

float(float effective) getcursormode = #0; /*
		Reports the cursor mode this module previously attempted to use. If 'effective' is true, reports the cursor mode currently active (if was overriden by a different module which has precidence, for instance, or if there is only a touchscreen and no mouse). */

float(float inputsequencenum) getinputstate = #345; /*
		Looks up an input frame from the log, setting the input_* globals accordingly.
		The sequence number range used for prediction should normally be servercommandframe < sequence <= clientcommandframe.
		The sequence equal to clientcommandframe will change between input frames. */

void(float sens) setsensitivityscaler = #346; /*
		Temporarily scales the player's mouse sensitivity based upon something like zoom, avoiding potential cvar saving and thus corruption. */

string(float playernum, string keyname) getplayerkeyvalue = #348; /*
		Look up a player's userinfo, to discover things like their name, topcolor, bottomcolor, skin, team, *ver.
		Also includes scoreboard info like frags, ping, pl, userid, entertime, as well as voipspeaking and voiploudness. */

float(float playernum, string keyname, optional float assumevalue) getplayerkeyfloat = #0; /*
		Cheaper version of getplayerkeyvalue that avoids the need for so many tempstrings. */

float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not */

float() isserver = #350; /*
		Returns if the client is acting as the server (aka: listen server) */

void(vector origin, vector forward, vector right, vector up, optional float reverbtype) SetListener = #351; /*
		Sets the position of the view, as far as the audio subsystem is concerned. This should be called once per CSQC_UpdateView as it will otherwise revert to default. For reverbtype, see setup_reverb or treat as 'underwater'. */

void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

string(string key) serverkey = #354; /*
		Look up a key in the server's public serverinfo string */

float(string key, optional float assumevalue) serverkeyfloat = #0; /*
		Version of serverkey that returns the value as a float (which avoids tempstrings). */

string(optional string resetstring) getentitytoken = #355; /*
		Grab the next token in the map's entity lump.
		If resetstring is not specified, the next token will be returned with no other sideeffects.
		If empty, will reset from the map before returning the first token, probably {.
		If not empty, will tokenize from that string instead.
		Always returns tempstrings. */

void(string evname, string evargs, ...) sendevent = #359; /*
		Invoke Cmd_evname_evargs in ssqc. evargs must be a string of initials refering to the types of the arguments to pass. v=vector, e=entity(.entnum field is sent), f=float, i=int. 6 arguments max - you can get more if you pack your floats into vectors. */

float() readbyte = #360;
float() readchar = #361;
float() readshort = #362;
float() readlong = #363;
float() readcoord = #364;
float() readangle = #365;
string() readstring = #366;
float() readfloat = #367;
float() readentitynum = #368;
void(string newcaption) setwindowcaption = #0; /*
		Replaces the title of the game window, as seen when task switching or just running in windowed mode. */

entity(entity from, optional entity to) copyentity = #400; /*
		Copies all fields from one entity to another. */

entity(.string field, string match, optional .entity chainfield) findchain = #402;
entity(.float fld, float match, optional .entity chainfield) findchainfloat = #403;
void(vector org, optional float count) te_gunshot = #418;
void(vector org) te_spike = #419;
void(vector org) te_superspike = #420;
void(vector org) te_explosion = #421;
void(vector org) te_tarexplosion = #422;
void(vector org) te_wizspike = #423;
void(vector org) te_knightspike = #424;
void(vector org) te_lavasplash = #425;
void(vector org) te_teleport = #426;
void(vector org, float color, float colorlength) te_explosion2 = #427;
void(entity own, vector start, vector end) te_lightning1 = #428;
void(entity own, vector start, vector end) te_lightning2 = #429;
void(entity own, vector start, vector end) te_lightning3 = #430;
void(entity own, vector start, vector end) te_beam = #431;
void(vector dir) vectorvectors = #432;
float(entity e, float s) getsurfacenumpoints = #434;
vector(entity e, float s, float n) getsurfacepoint = #435;
vector(entity e, float s) getsurfacenormal = #436;
string(entity e, float s) getsurfacetexture = #437;
float(entity e, vector p) getsurfacenearpoint = #438;
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439;
float(string s) tokenize = #441;
string(float n) argv = #442;
float() argc = #0;
void(entity e, entity tagentity, string tagname) setattachment = #443; /* */

searchhandle(string pattern, float flags, float quiet, optional string filterpackage) search_begin = #444; /*
		initiate a filesystem scan based upon filenames. Be sure to call search_end on the returned handle. */

void(searchhandle handle) search_end = #445; /* */

float(searchhandle handle) search_getsize = #446; /*
		 Retrieves the number of files that were found. */

string(searchhandle handle, float num) search_getfilename = #447; /*
		Retrieves name of one of the files that was found by the initial search. */

float(searchhandle handle, float num) search_getfilesize = #0; /*
		Retrieves the size of one of the files that was found by the initial search. */

string(searchhandle handle, float num) search_getfilemtime = #0; /*
		Retrieves modification time of one of the files in %Y-%m-%d %H:%M:%S format. */

string(searchhandle handle, float num) search_getpackagename = #0; /*
		Retrieves the name of the package the file was found inside. */

string(string cvarname) cvar_string = #448;
entity(entity start, .float fld, float match) findflags = #449;
entity(.float fld, float match, optional .entity chainfield) findchainflags = #450;
entity(float entnum) edict_num = #459;
strbuf() buf_create = #460;
void(strbuf bufhandle) buf_del = #461;
float(strbuf bufhandle) buf_getsize = #462;
void(strbuf bufhandle_from, strbuf bufhandle_to) buf_copy = #463;
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #464;
string(strbuf bufhandle, string glue) buf_implode = #465;
string(strbuf bufhandle, float string_index) bufstr_get = #466;
void(strbuf bufhandle, float string_index, string str) bufstr_set = #467;
float(strbuf bufhandle, string str, float order) bufstr_add = #468;
void(strbuf bufhandle, float string_index) bufstr_free = #469;
float(float s) asin = #471;
float(float c) acos = #472;
float(float t) atan = #473;
float(float c, float s) atan2 = #474;
float(float a) tan = #475;
float(string s) strlennocol = #476; /*
		Returns the number of characters in the string after any colour codes or other markup has been parsed. */

string(string s) strdecolorize = #477; /*
		Flattens any markup/colours, removing them from the string. */

string(float uselocaltime, string format, ...) strftime = #478;
float(string s, string separator1, ...) tokenizebyseparator = #479;
string(string s) strtolower = #480;
string(string s) strtoupper = #481;
string(string s) cvar_defstring = #482;
void(vector origin, string sample, float volume, float attenuation) pointsound = #483;
string(string search, string replace, string subject) strreplace = #484;
string(string search, string replace, string subject) strireplace = #485;
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486;
float(float caseinsensitive, string s, ...) crc16 = #494;
float(string name) cvar_type = #495;
float() numentityfields = #496; /*
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /*
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /*
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499;
float(float fieldnum, entity ent, string s) putentityfieldstring = #500;
string(string filename, optional float makereferenced) whichpack = #503; /*
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

__variant(float entnum, float fieldnum) getentity = #504; /*
		Looks up fields from non-csqc-visible entities. The entity will need to be within the player's pvs. fieldnum should be one of the GE_ constants. */

string(string in) uri_escape = #510;
string(string in) uri_unescape = #511;
float(entity ent) num_for_edict = #512;
float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

void(strbuf strbuf, string pattern, string antipattern) buf_cvarlist = #517; /*
		Populates the strbuf with a list of known cvar names. */

string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(optional float timetype) gettime = #519;
string(string command, optional float bindmap) findkeysforcommand = #521; /*
		Returns a list of keycodes that perform the given console command in a format that can only be parsed via tokenize (NOT tokenize_console). This always returns at least two values - if only one key is actually bound, -1 will be returned. The bindmap argument is listed for compatibility with dp-specific defs, but is ignored in FTE. */

string(string command, optional float bindmap) findkeysforcommandex = #0; /*
		Returns a list of key bindings in keyname format instead of keynums. Use tokenize to parse. This list may contain modifiers. May return large numbers of keys. */

float(float v, optional float base) log = #532; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(string sample) soundlength = #534; /*
		Provides a way to query the duration of a sound sample, allowing you to set up a timer to chain samples. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to a frik_file file handle. */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

vector(float mode, float forfullscreen) getresolution = #608; /*
		Returns available/common video modes. */

float(float type) gethostcachevalue = #611; /*
		Returns number of servers known */

string(float type, float hostnr) gethostcachestring = #612; /*
		Retrieves some specific type of info about the specified server. */

float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

void() resethostcachemasks = #615; /*
		Resets server listing filters. */

void() resorthostcache = #618; /*
		Rebuild the visible server list according to filters and sort terms */

void(float fld, float descending) sethostcachesort = #619; /*
		Changes which field to sort by. */

void(optional float dopurge) refreshhostcache = #620; /*
		Refresh all sources, requery maps, etc. */

float(float fld, float hostnr) gethostcachenumber = #621; /*
		Alternative to gethostcachestring, avoiding tempstrings. */

float(string key) gethostcacheindexforkey = #622; /*
		Retrieves a field index for the provided name */

string(float n, float prop) getgamedirinfo = #626; /*
		Provides a way to enumerate available mod directories. */

string(string fmt, ...) sprintf = #627;
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;
float(float key, string bind, optional float bindmap, optional float modifier) setkeybind = #630; /*
		Changes a key binding. */

string(string digest, string data, ...) digest_hex = #639;


//Builtin Stubs List (these are present for simpler compatibility, but not properly supported in QuakeSpasm at this time).
/*
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513;
void(float mask, float fld, string str, float op) sethostcachemaskstring = #616;
void(float mask, float fld, float num, float op) sethostcachemasknumber = #617;
void(string key) addwantedhostcachekey = #623;
vector() getbindmaps = #631;
float(vector bm) setbindmaps = #632;
*/
const float K_TAB = 9;
const float K_ENTER = 13;
const float K_ESCAPE = 27;
const float K_SPACE = 32;
const float K_BACKSPACE = 127;
const float K_UPARROW = 128;
const float K_DOWNARROW = 129;
const float K_LEFTARROW = 130;
const float K_RIGHTARROW = 131;
const float K_ALT = 132;
const float K_CTRL = 133;
const float K_SHIFT = 134;
const float K_F1 = 135;
const float K_F2 = 136;
const float K_F3 = 137;
const float K_F4 = 138;
const float K_F5 = 139;
const float K_F6 = 140;
const float K_F7 = 141;
const float K_F8 = 142;
const float K_F9 = 143;
const float K_F10 = 144;
const float K_F11 = 145;
const float K_F12 = 146;
const float K_INS = 147;
const float K_DEL = 148;
const float K_PGDN = 149;
const float K_PGUP = 150;
const float K_HOME = 151;
const float K_END = 152;
const float K_KP_SLASH = 168;
const float K_KP_STAR = 169;
const float K_KP_MINUS = 170;
const float K_KP_HOME = 164;
const float K_KP_UPARROW = 165;
const float K_KP_PGUP = 166;
const float K_KP_PLUS = 171;
const float K_KP_LEFTARROW = 161;
const float K_KP_5 = 162;
const float K_KP_RIGHTARROW = 163;
const float K_KP_END = 158;
const float K_KP_DOWNARROW = 159;
const float K_KP_PGDN = 160;
const float K_KP_ENTER = 172;
const float K_KP_INS = 157;
const float K_KP_DEL = 167;
const float K_COMMAND = -170;
const float K_MOUSE1 = 512;
const float K_MOUSE2 = 513;
const float K_MOUSE3 = 514;
const float K_JOY1 = 768;
const float K_JOY2 = 769;
const float K_JOY3 = 770;
const float K_JOY4 = 771;
const float K_AUX1 = 784;
const float K_AUX2 = 785;
const float K_AUX3 = 786;
const float K_AUX4 = 787;
const float K_AUX5 = 788;
const float K_AUX6 = 789;
const float K_AUX7 = 790;
const float K_AUX8 = 791;
const float K_AUX9 = 792;
const float K_AUX10 = 793;
const float K_AUX11 = 794;
const float K_AUX12 = 795;
const float K_AUX13 = 796;
const float K_AUX14 = 797;
const float K_AUX15 = 798;
const float K_AUX16 = 799;
const float K_AUX17 = 800;
const float K_AUX18 = 801;
const float K_AUX19 = 802;
const float K_AUX20 = 803;
const float K_AUX21 = 804;
const float K_AUX22 = 805;
const float K_AUX23 = 806;
const float K_AUX24 = 807;
const float K_AUX25 = 808;
const float K_AUX26 = 809;
const float K_AUX27 = 810;
const float K_AUX28 = 811;
const float K_AUX29 = 812;
const float K_AUX30 = 813;
const float K_AUX31 = 814;
const float K_AUX32 = 815;
const float K_MWHEELUP = 515;
const float K_MWHEELDOWN = 516;
const float K_MOUSE4 = 517;
const float K_MOUSE5 = 518;
const float K_LTHUMB = 822;
const float K_RTHUMB = 823;
const float K_LSHOULDER = 824;
const float K_RSHOULDER = 825;
const float K_ABUTTON = 826;
const float K_BBUTTON = 827;
const float K_XBUTTON = 828;
const float K_YBUTTON = 829;
const float K_LTRIGGER = 830;
const float K_RTRIGGER = 831;
const float K_PAUSE = 153;


//Reset this back to normal.
#pragma noref 0